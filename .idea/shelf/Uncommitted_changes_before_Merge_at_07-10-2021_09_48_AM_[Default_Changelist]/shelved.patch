Index: app/src/main/java/com/daily/events/calender/services/AlarmService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.daily.events.calender.services\r\n\r\nimport android.content.ComponentName\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.content.pm.PackageManager\r\nimport androidx.core.app.JobIntentService\r\nimport java.text.SimpleDateFormat\r\nimport java.util.*\r\n\r\nclass AlarmService : JobIntentService() {\r\n    override fun onHandleWork(intent: Intent) {\r\n        val dateLong = System.currentTimeMillis()\r\n        val currentDate = SimpleDateFormat(\"d\", Locale.getDefault()).format(dateLong)\r\n\r\n\r\n        for (i in 1..31) {\r\n            if (i == currentDate.toInt()) {\r\n                packageManager.setComponentEnabledSetting(\r\n                    ComponentName(\r\n                        applicationContext,\r\n                        \"com.daily.events.calender.LauncherAlias\" + i\r\n                    ),\r\n                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP\r\n                )\r\n            } else {\r\n                packageManager.setComponentEnabledSetting(\r\n                    ComponentName(\r\n                        applicationContext,\r\n                        \"com.daily.events.calender.LauncherAlias\" + i\r\n                    ),\r\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP\r\n                )\r\n            }\r\n        }\r\n//\r\n//        packageManager.setComponentEnabledSetting(ComponentName(applicationContext, \"com.daily.events.calender.LauncherAlias1\"), PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP)\r\n//        packageManager.setComponentEnabledSetting(ComponentName(applicationContext, \"com.daily.events.calender.LauncherAlias2\"), PackageManager.COMPONENT_ENABLED_STATE_ENABLED,PackageManager.DONT_KILL_APP)\r\n//        packageManager.setComponentEnabledSetting(ComponentName(applicationContext, \"com.daily.events.calender.LauncherAlias3\"), PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP)\r\n    }\r\n\r\n    companion object {\r\n        const val ANDROID_CHANNEL_ID = \"com.daily.events.calender\"\r\n\r\n        /**\r\n         * Unique job ID for this service.\r\n         */\r\n        const val JOB_ID = 1000\r\n        private const val TWO_MINUTES = 1000 * 60 * 2\r\n        fun enqueueWork(context: Context?, work: Intent?) {\r\n            enqueueWork(\r\n                context!!,\r\n                AlarmService::class.java, JOB_ID, work!!\r\n            )\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/daily/events/calender/services/AlarmService.kt	(revision e320d0952b3842a6ea71ad2e760e9d69df8e0a28)
+++ app/src/main/java/com/daily/events/calender/services/AlarmService.kt	(date 1633579179890)
@@ -13,7 +13,6 @@
         val dateLong = System.currentTimeMillis()
         val currentDate = SimpleDateFormat("d", Locale.getDefault()).format(dateLong)
 
-
         for (i in 1..31) {
             if (i == currentDate.toInt()) {
                 packageManager.setComponentEnabledSetting(
@@ -33,18 +32,11 @@
                 )
             }
         }
-//
-//        packageManager.setComponentEnabledSetting(ComponentName(applicationContext, "com.daily.events.calender.LauncherAlias1"), PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP)
-//        packageManager.setComponentEnabledSetting(ComponentName(applicationContext, "com.daily.events.calender.LauncherAlias2"), PackageManager.COMPONENT_ENABLED_STATE_ENABLED,PackageManager.DONT_KILL_APP)
-//        packageManager.setComponentEnabledSetting(ComponentName(applicationContext, "com.daily.events.calender.LauncherAlias3"), PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP)
     }
 
     companion object {
         const val ANDROID_CHANNEL_ID = "com.daily.events.calender"
 
-        /**
-         * Unique job ID for this service.
-         */
         const val JOB_ID = 1000
         private const val TWO_MINUTES = 1000 * 60 * 2
         fun enqueueWork(context: Context?, work: Intent?) {
Index: app/src/main/java/com/daily/events/calender/Activity/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.daily.events.calender.Activity\r\n\r\nimport android.app.Activity\r\nimport android.appwidget.AppWidgetManager\r\nimport android.content.*\r\nimport android.content.pm.PackageManager\r\nimport android.database.ContentObserver\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport android.os.Environment\r\nimport android.os.Handler\r\nimport android.provider.CalendarContract\r\nimport android.provider.ContactsContract\r\nimport android.text.TextUtils\r\nimport android.util.Log\r\nimport android.view.MenuItem\r\nimport android.view.View\r\nimport android.widget.LinearLayout\r\nimport android.widget.RelativeLayout\r\nimport android.widget.Toast\r\nimport androidx.appcompat.widget.SwitchCompat\r\nimport androidx.databinding.DataBindingUtil\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.fragment.app.FragmentManager\r\nimport androidx.loader.content.CursorLoader\r\nimport androidx.localbroadcastmanager.content.LocalBroadcastManager\r\nimport com.daily.events.calender.Extensions.*\r\nimport com.daily.events.calender.Fragment.*\r\nimport com.daily.events.calender.Fragment.Home.HomeFragment\r\nimport com.daily.events.calender.Model.Event\r\nimport com.daily.events.calender.Model.EventType\r\nimport com.daily.events.calender.R\r\nimport com.daily.events.calender.databinding.ActivityMainBinding\r\nimport com.daily.events.calender.dialogs.SetRemindersDialog\r\nimport com.daily.events.calender.helpers.*\r\nimport com.daily.events.calender.helpers.Formatter\r\nimport com.daily.events.calender.services.AlarmReceiver\r\nimport com.google.android.material.bottomnavigation.BottomNavigationView\r\nimport com.google.android.material.bottomsheet.BottomSheetBehavior\r\nimport com.google.android.material.bottomsheet.BottomSheetBehavior.BottomSheetCallback\r\nimport com.shrikanthravi.customnavigationdrawer2.widget.SNavigationDrawer\r\nimport com.simplemobiletools.commons.activities.BaseSimpleActivity\r\nimport com.simplemobiletools.commons.dialogs.RadioGroupDialog\r\nimport com.simplemobiletools.commons.extensions.*\r\nimport com.simplemobiletools.commons.helpers.*\r\nimport com.simplemobiletools.commons.models.RadioItem\r\nimport com.simplemobiletools.commons.models.SimpleContact\r\nimport kotlinx.android.synthetic.main.activity_main.*\r\nimport kotlinx.android.synthetic.main.calendar_item_account.view.*\r\nimport kotlinx.android.synthetic.main.calendar_item_calendar.view.*\r\nimport kotlinx.android.synthetic.main.dialog_select_calendars.view.*\r\nimport org.joda.time.DateTime\r\nimport org.joda.time.DateTimeZone\r\nimport pub.devrel.easypermissions.AppSettingsDialog.DEFAULT_SETTINGS_REQ_CODE\r\nimport pub.devrel.easypermissions.EasyPermissions\r\nimport java.text.SimpleDateFormat\r\nimport java.util.*\r\n\r\n\r\nclass MainActivity : SimpleActivity(), BottomNavigationView.OnNavigationItemSelectedListener {\r\n    //    var fragmentClass: Intrinsics.Kotlin<*>? = null\r\n    private var selectAccountReceiver: SelectAccountReceiver? = null\r\n    var IsSet = false\r\n    var homeFragment: HomeFragment? = null\r\n    var eventFragment: EventFragment? = null\r\n    var notificationFragment: NotificationFragment? = null\r\n    var settingFragment: SettingFragment? = null\r\n\r\n    companion object {\r\n\r\n        var fragment: Fragment? = null\r\n        val CALDAV_REFRESH_DELAY = 3000L\r\n        val calDAVRefreshHandler = Handler()\r\n        var calDAVRefreshCallback: (() -> Unit)? = null\r\n\r\n        lateinit var selectAccountBehaviour: BottomSheetBehavior<LinearLayout>\r\n        var mainBinding: ActivityMainBinding? = null\r\n\r\n        lateinit var activity: Activity\r\n\r\n        fun getSyncedCalDAVCalendars() =\r\n            activity.calDAVHelper.getCalDAVCalendars(activity.config.caldavSyncedCalendarIds, false)\r\n\r\n\r\n        fun syncCalDAVCalendars(callback: () -> Unit) {\r\n            calDAVRefreshCallback = callback\r\n            ensureBackgroundThread {\r\n                val uri = CalendarContract.Calendars.CONTENT_URI\r\n                activity.contentResolver.unregisterContentObserver(calDAVSyncObserver)\r\n                activity.contentResolver.registerContentObserver(uri, false, calDAVSyncObserver)\r\n                activity.refreshCalDAVCalendars(activity.config.caldavSyncedCalendarIds, true)\r\n            }\r\n        }\r\n\r\n        private val calDAVSyncObserver = object : ContentObserver(Handler()) {\r\n            override fun onChange(selfChange: Boolean) {\r\n                super.onChange(selfChange)\r\n                if (!selfChange) {\r\n                    calDAVRefreshHandler.removeCallbacksAndMessages(null)\r\n                    calDAVRefreshHandler.postDelayed({\r\n                        ensureBackgroundThread {\r\n                            unregisterObserver()\r\n                            calDAVRefreshCallback?.invoke()\r\n                            calDAVRefreshCallback = null\r\n                        }\r\n                    }, CALDAV_REFRESH_DELAY)\r\n                }\r\n            }\r\n        }\r\n\r\n        fun unregisterObserver() {\r\n            activity.contentResolver.unregisterContentObserver(calDAVSyncObserver)\r\n        }\r\n\r\n        private fun updateDefaultEventTypeText() {\r\n            if (activity.config.defaultEventTypeId == -1L) {\r\n\r\n            } else {\r\n                ensureBackgroundThread {\r\n                    val eventType =\r\n                        activity.eventTypesDB.getEventTypeWithId(activity.config.defaultEventTypeId)\r\n                    if (eventType != null) {\r\n                        activity.config.lastUsedCaldavCalendarId = eventType.caldavCalendarId\r\n                    } else {\r\n                        activity.config.defaultEventTypeId = -1\r\n                        updateDefaultEventTypeText()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        fun getMyContactsCursor(favoritesOnly: Boolean, withPhoneNumbersOnly: Boolean) = try {\r\n            val getFavoritesOnly = if (favoritesOnly) \"1\" else \"0\"\r\n            val getWithPhoneNumbersOnly = if (withPhoneNumbersOnly) \"1\" else \"0\"\r\n            val args = arrayOf(getFavoritesOnly, getWithPhoneNumbersOnly)\r\n            CursorLoader(\r\n                activity,\r\n                MyContactsContentProvider.CONTACTS_CONTENT_URI,\r\n                null,\r\n                null,\r\n                args,\r\n                null\r\n            )\r\n        } catch (e: Exception) {\r\n            null\r\n        }\r\n\r\n        fun updateWidgets() {\r\n            val widgetIDs = AppWidgetManager.getInstance(activity)?.getAppWidgetIds(\r\n                ComponentName(\r\n                    activity, MyWidgetMonthlyProvider::class.java\r\n                )\r\n            )\r\n                ?: return\r\n            if (widgetIDs.isNotEmpty()) {\r\n                Intent(activity, MyWidgetMonthlyProvider::class.java).apply {\r\n                    action = AppWidgetManager.ACTION_APPWIDGET_UPDATE\r\n                    putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIDs)\r\n                    activity.sendBroadcast(this)\r\n                }\r\n            }\r\n\r\n            updateListWidget()\r\n            updateDateWidget()\r\n        }\r\n\r\n        fun updateListWidget() {\r\n            val widgetIDs = AppWidgetManager.getInstance(activity)\r\n                ?.getAppWidgetIds(ComponentName(activity, MyWidgetListProvider::class.java))\r\n                ?: return\r\n            if (widgetIDs.isNotEmpty()) {\r\n                Intent(activity, MyWidgetListProvider::class.java).apply {\r\n                    action = AppWidgetManager.ACTION_APPWIDGET_UPDATE\r\n                    putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIDs)\r\n                    activity.sendBroadcast(this)\r\n                }\r\n            }\r\n        }\r\n\r\n        fun updateDateWidget() {\r\n            val widgetIDs = AppWidgetManager.getInstance(activity)\r\n                ?.getAppWidgetIds(ComponentName(activity, MyWidgetDateProvider::class.java))\r\n                ?: return\r\n            if (widgetIDs.isNotEmpty()) {\r\n                Intent(activity, MyWidgetDateProvider::class.java).apply {\r\n                    action = AppWidgetManager.ACTION_APPWIDGET_UPDATE\r\n                    putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIDs)\r\n                    activity.sendBroadcast(this)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onPostCreate(savedInstanceState: Bundle?) {\r\n        super.onPostCreate(savedInstanceState)\r\n        val currentDate = SimpleDateFormat(\"d\", Locale.getDefault()).format(Date())\r\n\r\n        for (i in 1..31) {\r\n            if (i == currentDate.toInt()) {\r\n                packageManager.setComponentEnabledSetting(\r\n                    ComponentName(\r\n                        applicationContext,\r\n                        \"com.daily.events.calender.LauncherAlias\" + i\r\n                    ),\r\n                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP\r\n                )\r\n            } else {\r\n                packageManager.setComponentEnabledSetting(\r\n                    ComponentName(\r\n                        applicationContext,\r\n                        \"com.daily.events.calender.LauncherAlias\" + i\r\n                    ),\r\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    private var showCalDAVRefreshToast = false\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        mainBinding =\r\n            DataBindingUtil.setContentView(this@MainActivity, R.layout.activity_main)\r\n\r\n        supportActionBar?.hide()\r\n\r\n        activity = this@MainActivity\r\n        val calendar = Calendar.getInstance()\r\n        AlarmReceiver().setRepeatAlarm(applicationContext, 1001, calendar)\r\n\r\n        if (config.caldavSync) {\r\n            refreshCalDAVCalendars(false)\r\n        }\r\n\r\n        selectAccountBehaviour =\r\n            BottomSheetBehavior.from(llBottom)\r\n\r\n        selectAccountBehaviour.addBottomSheetCallback(object : BottomSheetCallback() {\r\n            override fun onStateChanged(bottomSheet: View, newState: Int) {\r\n                if (newState == BottomSheetBehavior.STATE_COLLAPSED) {\r\n                    mainBinding?.hideBack?.beGone()\r\n                }\r\n            }\r\n            override fun onSlide(bottomSheet: View, slideOffset: Float) {}\r\n        })\r\n\r\n        selectAccountReceiver = SelectAccountReceiver()\r\n\r\n        LocalBroadcastManager.getInstance(this@MainActivity).registerReceiver(\r\n            selectAccountReceiver!!,\r\n            IntentFilter(\"OPEN_ACCOUNT_SYNC\")\r\n        )\r\n\r\n        LocalBroadcastManager.getInstance(this@MainActivity).registerReceiver(\r\n            holidayReceiver,\r\n            IntentFilter(\"ADD_HOLIDAYS\")\r\n        )\r\n\r\n        config.isSundayFirst = false\r\n\r\n        mainBinding?.fab?.setOnClickListener {\r\n\r\n            launchNewEventIntent(getNewEventDayCode())\r\n        }\r\n    }\r\n\r\n    fun getNewEventDayCode() = Formatter.getTodayCode()\r\n\r\n    override fun permissionGranted() {\r\n        if (!IsSet) SetFragments()\r\n    }\r\n\r\n    fun SetFragments() {\r\n\r\n        IsSet = true\r\n        homeFragment = HomeFragment()\r\n        eventFragment = EventFragment()\r\n        notificationFragment = NotificationFragment()\r\n        settingFragment = SettingFragment()\r\n        mainBinding?.bottomnavigationbar?.setOnNavigationItemSelectedListener(this)\r\n        setNavigationItems()\r\n        homeFragment?.let {\r\n            supportFragmentManager.beginTransaction().replace(R.id.container, it)\r\n                .commit()\r\n        }\r\n    }\r\n\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        super.onActivityResult(requestCode, resultCode, data)\r\n        if (requestCode == DEFAULT_SETTINGS_REQ_CODE) {\r\n\r\n            // Do something after user returned from app settings screen, like showing a Toast.\r\n            if (EasyPermissions.hasPermissions(this, *perms)) {\r\n                permissionGranted()\r\n            } else {\r\n                EasyPermissions.requestPermissions(\r\n                    this, getString(R.string.permission_str),\r\n                    RC_READ_EXTERNAL_STORAGE, *perms\r\n                )\r\n            }\r\n        }\r\n        if (requestCode == 2296) {\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\r\n                Log.e(\"hasPermissions\", \"true\")\r\n                if (Environment.isExternalStorageManager()) {\r\n                    permissionGranted()\r\n                } else {\r\n                    EasyPermissions.requestPermissions(\r\n                        this, getString(R.string.permission_str),\r\n                        BaseSimpleActivity.RC_READ_EXTERNAL_STORAGE, *perms\r\n                    )\r\n                    //                    Toasty.info(this, \"Allow permission for storage access!\", Toast.LENGTH_SHORT).show();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun refreshCalDAVCalendars(showRefreshToast: Boolean) {\r\n        showCalDAVRefreshToast = showRefreshToast\r\n        if (showRefreshToast) {\r\n            toast(R.string.refreshing)\r\n        }\r\n\r\n        syncCalDAVCalendars {\r\n            calDAVHelper.refreshCalendars(true) {\r\n                calDAVChanged()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun calDAVChanged() {\r\n        if (showCalDAVRefreshToast) {\r\n            toast(R.string.refreshing_complete)\r\n        }\r\n    }\r\n\r\n    override fun onBackPressed() {\r\n        super.onBackPressed()\r\n        if (selectAccountBehaviour.state == BottomSheetBehavior.STATE_EXPANDED) {\r\n            selectAccountBehaviour.state = BottomSheetBehavior.STATE_COLLAPSED\r\n            mainBinding?.hideBack?.beGone()\r\n        }\r\n    }\r\n\r\n    fun setNavigationItems() {\r\n        val menuItems: MutableList<com.shrikanthravi.customnavigationdrawer2.data.MenuItem> =\r\n            ArrayList()\r\n        menuItems.add(\r\n            com.shrikanthravi.customnavigationdrawer2.data.MenuItem(\r\n                \"Home\",\r\n                R.drawable.ic_side_select,\r\n                R.drawable.ic_home_new\r\n            )\r\n        )\r\n        menuItems.add(\r\n            com.shrikanthravi.customnavigationdrawer2.data.MenuItem(\r\n                \"Event\",\r\n                R.drawable.ic_side_select,\r\n                R.drawable.ic_event_new\r\n            )\r\n        )\r\n        menuItems.add(\r\n            com.shrikanthravi.customnavigationdrawer2.data.MenuItem(\r\n                \"Notification\",\r\n                R.drawable.ic_side_select,\r\n                R.drawable.ic_notification_new\r\n            )\r\n        )\r\n        menuItems.add(\r\n            com.shrikanthravi.customnavigationdrawer2.data.MenuItem(\r\n                \"Setting\",\r\n                R.drawable.ic_side_select,\r\n                R.drawable.ic_setting_new\r\n            )\r\n        )\r\n        mainBinding?.navigationDrawer?.menuItemList = menuItems\r\n\r\n        try {\r\n            fragment = HomeFragment()\r\n        } catch (e: java.lang.Exception) {\r\n            e.printStackTrace()\r\n        }\r\n        val fragmentManager: FragmentManager = supportFragmentManager\r\n        fragment?.let {\r\n            fragmentManager.beginTransaction()\r\n                .setCustomAnimations(android.R.animator.fade_in, android.R.animator.fade_out)\r\n                .replace(\r\n                    R.id.container,\r\n                    it\r\n                ).commit()\r\n        }\r\n\r\n        mainBinding?.navigationDrawer?.onMenuItemClickListener =\r\n            SNavigationDrawer.OnMenuItemClickListener { position ->\r\n\r\n                when (position) {\r\n                    0 -> {\r\n                        mainBinding?.fab?.visibility = View.VISIBLE\r\n                        fragment = HomeFragment()\r\n                    }\r\n                    1 -> {\r\n                        mainBinding?.fab?.visibility = View.GONE\r\n                        fragment = EventFragment()\r\n                    }\r\n                    2 -> {\r\n                        mainBinding?.fab?.visibility = View.GONE\r\n                        fragment = NotificationFragment()\r\n                    }\r\n                    3 -> {\r\n                        mainBinding?.fab?.visibility = View.GONE\r\n                        fragment = SettingFragment()\r\n                    }\r\n                }\r\n                mainBinding?.navigationDrawer?.drawerListener =\r\n                    object : SNavigationDrawer.DrawerListener {\r\n                        override fun onDrawerOpened() {\r\n                            mainBinding?.topRL?.visibility = View.GONE\r\n                        }\r\n\r\n                        override fun onDrawerOpening() {}\r\n                        override fun onDrawerClosing() {\r\n                            println(\"Drawer closed\")\r\n                            mainBinding?.topRL?.visibility = View.VISIBLE\r\n                            if (fragment != null) {\r\n                                val fragmentManager = supportFragmentManager\r\n                                fragmentManager.beginTransaction().setCustomAnimations(\r\n                                    android.R.animator.fade_in,\r\n                                    android.R.animator.fade_out\r\n                                ).replace(\r\n                                    R.id.container,\r\n                                    fragment!!\r\n                                ).commit()\r\n                            }\r\n                        }\r\n\r\n                        override fun onDrawerClosed() {}\r\n                        override fun onDrawerStateChanged(newState: Int) {\r\n                            println(\"State $newState\")\r\n                        }\r\n                    }\r\n            }\r\n    }\r\n\r\n    override fun onNavigationItemSelected(item: MenuItem): Boolean {\r\n        when (item.itemId) {\r\n            R.id.home -> {\r\n                homeFragment?.let {\r\n                    supportFragmentManager.beginTransaction().replace(R.id.container, it)\r\n                        .commit()\r\n                }\r\n                mainBinding?.today?.beVisible()\r\n                return true\r\n            }\r\n            R.id.event -> {\r\n                eventFragment?.let {\r\n                    supportFragmentManager.beginTransaction().replace(R.id.container, it)\r\n                        .commit()\r\n                }\r\n                mainBinding?.today?.beGone()\r\n                return true\r\n            }\r\n            R.id.notification -> {\r\n                notificationFragment?.let {\r\n                    supportFragmentManager.beginTransaction().replace(R.id.container, it)\r\n                        .commit()\r\n                }\r\n                mainBinding?.today?.beGone()\r\n                return true\r\n            }\r\n\r\n            R.id.setting -> {\r\n                settingFragment?.let {\r\n                    supportFragmentManager.beginTransaction().replace(R.id.container, it)\r\n                        .commit()\r\n                }\r\n                mainBinding?.today?.beGone()\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    fun openMonthFromYearly(dateTime: DateTime) {\r\n        val fragment = MonthFragmentsHolder()\r\n        val bundle = Bundle()\r\n        bundle.putString(DAY_CODE, Formatter.getDayCodeFromDateTime(dateTime))\r\n        fragment.arguments = bundle\r\n        supportFragmentManager.beginTransaction().replace(R.id.container1, fragment).commitNow()\r\n        homeFragment?.monthChanges()\r\n    }\r\n\r\n    fun openDayFromMonthly(dateTime: DateTime) {\r\n//        val fragment = DayFragmentsHolder()\r\n//        val bundle = Bundle()\r\n//        bundle.putString(DAY_CODE, Formatter.getDayCodeFromDateTime(dateTime))\r\n//        fragment.arguments = bundle\r\n//        try {\r\n//            supportFragmentManager.beginTransaction().replace(R.id.container1, fragment).commitNow()\r\n//            homeFragment?.dayChanges()\r\n//        } catch (e: Exception) {\r\n//        }\r\n    }\r\n\r\n    fun toggleGoToTodayVisibility(beVisible: Boolean) {\r\n//        shouldGoToTodayBeVisible = beVisible\r\n//        if (goToTodayButton?.isVisible != beVisible) {\r\n//            invalidateOptionsMenu()\r\n//        }\r\n    }\r\n\r\n    private class SelectAccountReceiver : BroadcastReceiver() {\r\n\r\n\r\n        override fun onReceive(context: Context, intent: Intent) {\r\n\r\n            var prevAccount = \"\"\r\n\r\n            selectAccountBehaviour.state = BottomSheetBehavior.STATE_EXPANDED\r\n            mainBinding?.hideBack?.beVisible()\r\n\r\n            val ids = context.config.getSyncedCalendarIdsAsList()\r\n            val calendars = context.calDAVHelper.getCalDAVCalendars(\"\", true)\r\n            mainBinding?.llMain?.dialogSelectCalendarsPlaceholder?.beVisibleIf(calendars.isEmpty())\r\n            mainBinding?.llMain?.dialogSelectCalendarsHolder?.beVisibleIf(calendars.isNotEmpty())\r\n\r\n            mainBinding?.llMain?.dialogSelectCalendarsHolder?.removeAllViews()\r\n\r\n            val sorted = calendars.sortedWith(compareBy({ it.accountName }, { it.displayName }))\r\n            sorted.forEach {\r\n                if (prevAccount != it.accountName) {\r\n                    prevAccount = it.accountName\r\n                    addCalendarItem(false, it.accountName)\r\n                }\r\n\r\n                addCalendarItem(true, it.displayName, it.id, ids.contains(it.id))\r\n            }\r\n\r\n            mainBinding?.llMain?.dialogSubmit?.setOnClickListener {\r\n                Log.e(\r\n                    \"LLL_Bool: \",\r\n                    mainBinding?.llMain?.calendarItemBirthdaySwitch?.isChecked.toString()\r\n                )\r\n                confirmSelection(mainBinding?.llMain?.calendarItemBirthdaySwitch?.isChecked!!)\r\n            }\r\n\r\n            mainBinding?.llMain?.dialogCancel?.setOnClickListener {\r\n                selectAccountBehaviour.state = BottomSheetBehavior.STATE_COLLAPSED\r\n                mainBinding?.hideBack?.beGone()\r\n            }\r\n        }\r\n\r\n        fun addCalendarItem(\r\n            isEvent: Boolean,\r\n            text: String,\r\n            tag: Int = 0,\r\n            shouldCheck: Boolean = false\r\n        ) {\r\n            val layout =\r\n                if (isEvent) R.layout.calendar_item_calendar else R.layout.calendar_item_account\r\n            val calendarItem = activity.layoutInflater.inflate(\r\n                layout,\r\n                mainBinding?.llMain?.dialogSelectCalendarsHolder,\r\n                false\r\n            )\r\n\r\n            mainBinding?.llMain?.calendarItemBirthdaySwitch?.apply {\r\n                this.text = \"Add Contact Birthday\"\r\n                isChecked = shouldCheck\r\n                mainBinding?.llMain?.calendarItemBirthdaySwitch?.setOnClickListener {\r\n                    toggle()\r\n                }\r\n            }\r\n\r\n            mainBinding?.llMain?.calendarItemAnniversarySwitch?.apply {\r\n                this.text = \"Add Contact Anniversary\"\r\n                isChecked = shouldCheck\r\n                mainBinding?.llMain?.calendarItemBirthdaySwitch?.setOnClickListener {\r\n                    toggle()\r\n                }\r\n            }\r\n\r\n            if (isEvent) {\r\n                calendarItem.calendar_item_calendar_switch.apply {\r\n                    this.tag = tag\r\n                    this.text = text\r\n                    isChecked = shouldCheck\r\n                    calendarItem.setOnClickListener {\r\n                        toggle()\r\n                    }\r\n                }\r\n            } else {\r\n                calendarItem.calendar_item_account.text = text\r\n            }\r\n\r\n            mainBinding?.llMain?.dialogSelectCalendarsHolder?.addView(calendarItem)\r\n\r\n        }\r\n\r\n        private fun confirmSelection(isAdded: Boolean) {\r\n            val oldCalendarIds = activity.config.getSyncedCalendarIdsAsList()\r\n            val calendarIds = ArrayList<Int>()\r\n            val childCnt = mainBinding?.llMain?.dialogSelectCalendarsHolder?.childCount\r\n            for (i in 0..childCnt!!) {\r\n                val child = mainBinding?.llMain?.dialogSelectCalendarsHolder?.getChildAt(i)\r\n                if (child is RelativeLayout) {\r\n                    val check = child.getChildAt(0)\r\n                    if (check is SwitchCompat && check.isChecked) {\r\n                        calendarIds.add(check.tag as Int)\r\n                    }\r\n                }\r\n            }\r\n            tryAddBirthdays(isAdded)\r\n            activity.config.caldavSyncedCalendarIds = TextUtils.join(\",\", calendarIds)\r\n\r\n            val newCalendarIds = activity.config.getSyncedCalendarIdsAsList()\r\n\r\n            activity.config.caldavSync = newCalendarIds.isNotEmpty()\r\n            if (newCalendarIds.isNotEmpty()) {\r\n                Toast.makeText(\r\n                    activity,\r\n                    activity.resources.getString(R.string.syncing),\r\n                    Toast.LENGTH_SHORT\r\n                ).show()\r\n            }\r\n\r\n            ensureBackgroundThread {\r\n                if (newCalendarIds.isNotEmpty()) {\r\n                    val existingEventTypeNames = activity.eventsHelper.getEventTypesSync().map {\r\n                        it.getDisplayTitle()\r\n                            .lowercase(Locale.getDefault())\r\n                    } as ArrayList<String>\r\n                    getSyncedCalDAVCalendars().forEach {\r\n                        val calendarTitle = it.getFullTitle()\r\n                        if (!existingEventTypeNames.contains(calendarTitle.lowercase(Locale.getDefault()))) {\r\n                            val eventType = EventType(\r\n                                null,\r\n                                it.displayName,\r\n                                it.color,\r\n                                it.id,\r\n                                it.displayName,\r\n                                it.accountName\r\n                            )\r\n                            existingEventTypeNames.add(calendarTitle.lowercase(Locale.getDefault()))\r\n                            activity.eventsHelper.insertOrUpdateEventType(activity, eventType)\r\n                        }\r\n                    }\r\n\r\n                    syncCalDAVCalendars {\r\n                        activity.calDAVHelper.refreshCalendars(true) {\r\n                            if (newCalendarIds.isNotEmpty()) {\r\n//                                Toast.makeText(\r\n//                                    activity,\r\n//                                    activity.resources.getString(R.string.synchronization_completed),\r\n//                                    Toast.LENGTH_SHORT\r\n//                                ).show()\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                val removedCalendarIds = oldCalendarIds.filter { !newCalendarIds.contains(it) }\r\n                removedCalendarIds.forEach {\r\n                    activity.calDAVHelper.deleteCalDAVCalendarEvents(it.toLong())\r\n                    activity.eventsHelper.getEventTypeWithCalDAVCalendarId(it)?.apply {\r\n                        activity.eventsHelper.deleteEventTypes(arrayListOf(this), true)\r\n                    }\r\n                }\r\n\r\n                activity.eventTypesDB.deleteEventTypesWithCalendarId(removedCalendarIds)\r\n                updateDefaultEventTypeText()\r\n            }\r\n            selectAccountBehaviour.state = BottomSheetBehavior.STATE_COLLAPSED\r\n            mainBinding?.hideBack?.beGone()\r\n        }\r\n\r\n        private fun tryAddBirthdays(isAdded: Boolean) {\r\n            val isGranted = EasyPermissions.hasPermissions(activity, *perms)\r\n            if (isGranted) {\r\n                SetRemindersDialog(activity) {\r\n                    val reminders = it\r\n                    val privateCursor = getMyContactsCursor(false, false)?.loadInBackground()\r\n\r\n                    ensureBackgroundThread {\r\n                        val privateContacts =\r\n                            MyContactsContentProvider.getSimpleContacts(activity, privateCursor)\r\n                        addPrivateEvents(\r\n                            true,\r\n                            privateContacts,\r\n                            reminders\r\n                        ) { eventsFound, eventsAdded ->\r\n                            addContactEvents(true, reminders, eventsFound, eventsAdded) {\r\n                                when {\r\n                                    it > 0 -> {\r\n                                        Toast.makeText(\r\n                                            activity,\r\n                                            R.string.birthdays_added,\r\n                                            Toast.LENGTH_SHORT\r\n                                        ).show()\r\n                                        setupQuickFilter(isAdded)\r\n                                    }\r\n                                    it == -1 -> Toast.makeText(\r\n                                        activity,\r\n                                        R.string.no_new_birthdays,\r\n                                        Toast.LENGTH_SHORT\r\n                                    ).show()\r\n                                    else -> Toast.makeText(\r\n                                        activity,\r\n                                        R.string.no_birthdays,\r\n                                        Toast.LENGTH_SHORT\r\n                                    ).show()\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                Toast.makeText(\r\n                    activity,\r\n                    R.string.no_contacts_permission,\r\n                    Toast.LENGTH_SHORT\r\n                ).show()\r\n            }\r\n        }\r\n\r\n        private fun addContactEvents(\r\n            birthdays: Boolean,\r\n            reminders: ArrayList<Int>,\r\n            initEventsFound: Int,\r\n            initEventsAdded: Int,\r\n            callback: (Int) -> Unit\r\n        ) {\r\n            var eventsFound = initEventsFound\r\n            var eventsAdded = initEventsAdded\r\n            val uri = ContactsContract.Data.CONTENT_URI\r\n            val projection = arrayOf(\r\n                ContactsContract.Contacts.DISPLAY_NAME,\r\n                ContactsContract.CommonDataKinds.Event.CONTACT_ID,\r\n                ContactsContract.CommonDataKinds.Event.CONTACT_LAST_UPDATED_TIMESTAMP,\r\n                ContactsContract.CommonDataKinds.Event.START_DATE\r\n            )\r\n\r\n            val selection =\r\n                \"${ContactsContract.Data.MIMETYPE} = ? AND ${ContactsContract.CommonDataKinds.Event.TYPE} = ?\"\r\n            val type =\r\n                if (birthdays) ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY else ContactsContract.CommonDataKinds.Event.TYPE_ANNIVERSARY\r\n            val selectionArgs =\r\n                arrayOf(ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE, type.toString())\r\n\r\n            val dateFormats = getDateFormats()\r\n            val yearDateFormats = getDateFormatsWithYear()\r\n            val existingEvents =\r\n                if (birthdays) activity.eventsDB.getBirthdays() else activity.eventsDB.getAnniversaries()\r\n            val importIDs = HashMap<String, Long>()\r\n            existingEvents.forEach {\r\n                importIDs[it.importId] = it.startTS\r\n            }\r\n\r\n            val eventTypeId =\r\n                if (birthdays) activity.eventsHelper.getBirthdaysEventTypeId() else activity.eventsHelper.getAnniversariesEventTypeId()\r\n            val source = if (birthdays) SOURCE_CONTACT_BIRTHDAY else SOURCE_CONTACT_ANNIVERSARY\r\n\r\n            activity.queryCursor(\r\n                uri,\r\n                projection,\r\n                selection,\r\n                selectionArgs,\r\n                showErrors = true\r\n            ) { cursor ->\r\n                val contactId =\r\n                    cursor.getIntValue(ContactsContract.CommonDataKinds.Event.CONTACT_ID).toString()\r\n                val name = cursor.getStringValue(ContactsContract.Contacts.DISPLAY_NAME)\r\n                val startDate =\r\n                    cursor.getStringValue(ContactsContract.CommonDataKinds.Event.START_DATE)\r\n\r\n                for (format in dateFormats) {\r\n                    try {\r\n                        val formatter = SimpleDateFormat(format, Locale.getDefault())\r\n                        val date = formatter.parse(startDate)\r\n                        val flags = if (format in yearDateFormats) {\r\n                            FLAG_ALL_DAY\r\n                        } else {\r\n                            FLAG_ALL_DAY or FLAG_MISSING_YEAR\r\n                        }\r\n\r\n                        val timestamp = date.time / 1000L\r\n                        val lastUpdated =\r\n                            cursor.getLongValue(ContactsContract.CommonDataKinds.Event.CONTACT_LAST_UPDATED_TIMESTAMP)\r\n                        val event = Event(\r\n                            null,\r\n                            timestamp,\r\n                            timestamp,\r\n                            name,\r\n                            reminder1Minutes = reminders[0],\r\n                            reminder2Minutes = reminders[1],\r\n                            reminder3Minutes = reminders[2],\r\n                            importId = contactId,\r\n                            timeZone = DateTimeZone.getDefault().id,\r\n                            flags = flags,\r\n                            repeatInterval = YEAR,\r\n                            repeatRule = REPEAT_SAME_DAY,\r\n                            eventType = eventTypeId,\r\n                            source = source,\r\n                            lastUpdated = lastUpdated\r\n                        )\r\n\r\n                        val importIDsToDelete = ArrayList<String>()\r\n                        for ((key, value) in importIDs) {\r\n                            if (key == contactId && value != timestamp) {\r\n                                val deleted =\r\n                                    activity.eventsDB.deleteBirthdayAnniversary(source, key)\r\n                                if (deleted == 1) {\r\n                                    importIDsToDelete.add(key)\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        importIDsToDelete.forEach {\r\n                            importIDs.remove(it)\r\n                        }\r\n\r\n                        eventsFound++\r\n                        if (!importIDs.containsKey(contactId)) {\r\n                            activity.eventsHelper.insertEvent(event, false, false) {\r\n                                eventsAdded++\r\n                            }\r\n                        }\r\n                        break\r\n                    } catch (e: Exception) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            activity.runOnUiThread {\r\n                callback(if (eventsAdded == 0 && eventsFound > 0) -1 else eventsAdded)\r\n            }\r\n        }\r\n\r\n        private fun addPrivateEvents(\r\n            birthdays: Boolean,\r\n            contacts: ArrayList<SimpleContact>,\r\n            reminders: ArrayList<Int>,\r\n            callback: (eventsFound: Int, eventsAdded: Int) -> Unit\r\n        ) {\r\n            var eventsAdded = 0\r\n            var eventsFound = 0\r\n            if (contacts.isEmpty()) {\r\n                callback(0, 0)\r\n                return\r\n            }\r\n\r\n            try {\r\n                val eventTypeId =\r\n                    if (birthdays) activity.eventsHelper.getBirthdaysEventTypeId() else activity.eventsHelper.getAnniversariesEventTypeId()\r\n                val source = if (birthdays) SOURCE_CONTACT_BIRTHDAY else SOURCE_CONTACT_ANNIVERSARY\r\n\r\n                val existingEvents =\r\n                    if (birthdays) activity.eventsDB.getBirthdays() else activity.eventsDB.getAnniversaries()\r\n                val importIDs = HashMap<String, Long>()\r\n                existingEvents.forEach {\r\n                    importIDs[it.importId] = it.startTS\r\n                }\r\n\r\n                contacts.forEach { contact ->\r\n                    val events = if (birthdays) contact.birthdays else contact.anniversaries\r\n                    events.forEach { birthdayAnniversary ->\r\n                        // private contacts are created in Simple Contacts Pro, so we can guarantee that they exist only in these 2 formats\r\n                        val format = if (birthdayAnniversary.startsWith(\"--\")) {\r\n                            \"--MM-dd\"\r\n                        } else {\r\n                            \"yyyy-MM-dd\"\r\n                        }\r\n\r\n                        val formatter = SimpleDateFormat(format, Locale.getDefault())\r\n                        val date = formatter.parse(birthdayAnniversary)\r\n                        if (date.year < 70) {\r\n                            date.year = 70\r\n                        }\r\n\r\n                        val timestamp = date.time / 1000L\r\n                        val lastUpdated = System.currentTimeMillis()\r\n                        val event = Event(\r\n                            null,\r\n                            timestamp,\r\n                            timestamp,\r\n                            contact.name,\r\n                            reminder1Minutes = reminders[0],\r\n                            reminder2Minutes = reminders[1],\r\n                            reminder3Minutes = reminders[2],\r\n                            importId = contact.contactId.toString(),\r\n                            timeZone = DateTimeZone.getDefault().id,\r\n                            flags = FLAG_ALL_DAY,\r\n                            repeatInterval = YEAR,\r\n                            repeatRule = REPEAT_SAME_DAY,\r\n                            eventType = eventTypeId,\r\n                            source = source,\r\n                            lastUpdated = lastUpdated\r\n                        )\r\n\r\n                        val importIDsToDelete = ArrayList<String>()\r\n                        for ((key, value) in importIDs) {\r\n                            if (key == contact.contactId.toString() && value != timestamp) {\r\n                                val deleted =\r\n                                    activity.eventsDB.deleteBirthdayAnniversary(source, key)\r\n                                if (deleted == 1) {\r\n                                    importIDsToDelete.add(key)\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        importIDsToDelete.forEach {\r\n                            importIDs.remove(it)\r\n                        }\r\n\r\n                        eventsFound++\r\n                        if (!importIDs.containsKey(contact.contactId.toString())) {\r\n                            activity.eventsHelper.insertEvent(event, false, false) {\r\n                                eventsAdded++\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } catch (e: Exception) {\r\n                Log.e(\"LLL_Error: \", \"Add Contact ${e.localizedMessage}\")\r\n            }\r\n\r\n            callback(eventsFound, eventsAdded)\r\n        }\r\n\r\n        private fun setupQuickFilter(isAdded: Boolean) {\r\n            activity.eventsHelper.getEventTypes(activity, false) {\r\n                if (isAdded) {\r\n                    activity.config.displayEventTypes.plus(\r\n                        activity.eventsHelper.getBirthdaysEventTypeId().toString()\r\n                    )\r\n                } else {\r\n                    activity.config.displayEventTypes.minus(\r\n                        activity.eventsHelper.getBirthdaysEventTypeId().toString()\r\n                    )\r\n                }\r\n                updateWidgets()\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /******************** Add holidays *************************/\r\n    private val holidayReceiver: BroadcastReceiver = object : BroadcastReceiver() {\r\n        override fun onReceive(context: Context, intent: Intent) {\r\n            addHolidays()\r\n        }\r\n    }\r\n\r\n    private fun addHolidays() {\r\n        val items = getHolidayRadioItems()\r\n        RadioGroupDialog(this, items) {\r\n            toast(R.string.importing)\r\n            ensureBackgroundThread {\r\n                val holidays = getString(R.string.holidays)\r\n                var eventTypeId = eventsHelper.getEventTypeIdWithTitle(holidays)\r\n                if (eventTypeId == -1L) {\r\n                    val eventType = EventType(\r\n                        null,\r\n                        holidays,\r\n                        resources.getColor(R.color.default_holidays_color)\r\n                    )\r\n                    eventTypeId = eventsHelper.insertOrUpdateEventTypeSync(eventType)\r\n                }\r\n\r\n                val result = IcsImporter(this).importEvents(it as String, eventTypeId, 0, false)\r\n                handleParseResult(result)\r\n                if (result != IcsImporter.ImportResult.IMPORT_FAIL) {\r\n                    runOnUiThread {\r\n\r\n                        homeFragment?.let {\r\n                            supportFragmentManager.beginTransaction().replace(R.id.container, it)\r\n                                .commit()\r\n                        }\r\n                        mainBinding?.bottomnavigationbar?.menu?.findItem(R.id.home)?.isChecked =\r\n                            true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun getHolidayRadioItems(): ArrayList<RadioItem> {\r\n        val items = ArrayList<RadioItem>()\r\n\r\n        LinkedHashMap<String, String>().apply {\r\n            put(\"Algeria\", \"algeria.ics\")\r\n            put(\"Argentina\", \"argentina.ics\")\r\n            put(\"Australia\", \"australia.ics\")\r\n            put(\"België\", \"belgium.ics\")\r\n            put(\"Bolivia\", \"bolivia.ics\")\r\n            put(\"Brasil\", \"brazil.ics\")\r\n            put(\"България\", \"bulgaria.ics\")\r\n            put(\"Canada\", \"canada.ics\")\r\n            put(\"China\", \"china.ics\")\r\n            put(\"Colombia\", \"colombia.ics\")\r\n            put(\"Česká republika\", \"czech.ics\")\r\n            put(\"Danmark\", \"denmark.ics\")\r\n            put(\"Deutschland\", \"germany.ics\")\r\n            put(\"Eesti\", \"estonia.ics\")\r\n            put(\"España\", \"spain.ics\")\r\n            put(\"Éire\", \"ireland.ics\")\r\n            put(\"France\", \"france.ics\")\r\n            put(\"Fürstentum Liechtenstein\", \"liechtenstein.ics\")\r\n            put(\"Hellas\", \"greece.ics\")\r\n            put(\"Hrvatska\", \"croatia.ics\")\r\n            put(\"India\", \"india.ics\")\r\n            put(\"Indonesia\", \"indonesia.ics\")\r\n            put(\"Ísland\", \"iceland.ics\")\r\n            put(\"Israel\", \"israel.ics\")\r\n            put(\"Italia\", \"italy.ics\")\r\n            put(\"Қазақстан Республикасы\", \"kazakhstan.ics\")\r\n            put(\"المملكة المغربية\", \"morocco.ics\")\r\n            put(\"Latvija\", \"latvia.ics\")\r\n            put(\"Lietuva\", \"lithuania.ics\")\r\n            put(\"Luxemburg\", \"luxembourg.ics\")\r\n            put(\"Makedonija\", \"macedonia.ics\")\r\n            put(\"Malaysia\", \"malaysia.ics\")\r\n            put(\"Magyarország\", \"hungary.ics\")\r\n            put(\"México\", \"mexico.ics\")\r\n            put(\"Nederland\", \"netherlands.ics\")\r\n            put(\"República de Nicaragua\", \"nicaragua.ics\")\r\n            put(\"日本\", \"japan.ics\")\r\n            put(\"Nigeria\", \"nigeria.ics\")\r\n            put(\"Norge\", \"norway.ics\")\r\n            put(\"Österreich\", \"austria.ics\")\r\n            put(\"Pākistān\", \"pakistan.ics\")\r\n            put(\"Polska\", \"poland.ics\")\r\n            put(\"Portugal\", \"portugal.ics\")\r\n            put(\"Россия\", \"russia.ics\")\r\n            put(\"República de Costa Rica\", \"costarica.ics\")\r\n            put(\"República Oriental del Uruguay\", \"uruguay.ics\")\r\n            put(\"République d'Haïti\", \"haiti.ics\")\r\n            put(\"România\", \"romania.ics\")\r\n            put(\"Schweiz\", \"switzerland.ics\")\r\n            put(\"Singapore\", \"singapore.ics\")\r\n            put(\"한국\", \"southkorea.ics\")\r\n            put(\"Srbija\", \"serbia.ics\")\r\n            put(\"Slovenija\", \"slovenia.ics\")\r\n            put(\"Slovensko\", \"slovakia.ics\")\r\n            put(\"South Africa\", \"southafrica.ics\")\r\n            put(\"Suomi\", \"finland.ics\")\r\n            put(\"Sverige\", \"sweden.ics\")\r\n            put(\"Taiwan\", \"taiwan.ics\")\r\n            put(\"ราชอาณาจักรไทย\", \"thailand.ics\")\r\n            put(\"Türkiye Cumhuriyeti\", \"turkey.ics\")\r\n            put(\"Ukraine\", \"ukraine.ics\")\r\n            put(\"United Kingdom\", \"unitedkingdom.ics\")\r\n            put(\"United States\", \"unitedstates.ics\")\r\n\r\n            var i = 0\r\n            for ((country, file) in this) {\r\n                items.add(RadioItem(i++, country, file))\r\n            }\r\n        }\r\n\r\n        return items\r\n    }\r\n\r\n    private fun handleParseResult(result: IcsImporter.ImportResult) {\r\n        toast(\r\n            when (result) {\r\n                IcsImporter.ImportResult.IMPORT_NOTHING_NEW -> R.string.no_new_items\r\n                IcsImporter.ImportResult.IMPORT_OK -> R.string.holidays_imported_successfully\r\n                IcsImporter.ImportResult.IMPORT_PARTIAL -> R.string.importing_some_holidays_failed\r\n                else -> R.string.importing_holidays_failed\r\n            }, Toast.LENGTH_LONG\r\n        )\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/daily/events/calender/Activity/MainActivity.kt	(revision e320d0952b3842a6ea71ad2e760e9d69df8e0a28)
+++ app/src/main/java/com/daily/events/calender/Activity/MainActivity.kt	(date 1633577967677)
@@ -81,7 +81,6 @@
         fun getSyncedCalDAVCalendars() =
             activity.calDAVHelper.getCalDAVCalendars(activity.config.caldavSyncedCalendarIds, false)
 
-
         fun syncCalDAVCalendars(callback: () -> Unit) {
             calDAVRefreshCallback = callback
             ensureBackgroundThread {
